Необходимая база по питону для Ml-Engineer'a

---
## Вопросы

### Асинхронность, конкурентность и параллелизм

#### Вопрос: 1. Асинхронное программирование: механика и применение
**Ответ:**
**Что это такое на самом деле?**  
Асинхронность в Python (`asyncio`) — это **кооперативная многозадачность** в одном потоке.  
Представь шахматиста, который играет сеанс одновременной игры с 10 соперниками. Он делает ход на первой доске и, пока соперник думает (аналог ожидания ответа от базы данных или API), он не стоит и не ждет, а переходит ко второй доске. Шахматист один (один поток), но игры идут «параллельно».

**Как это работает:**
  
1. **Event Loop (Цикл событий):** Это бесконечный цикл `while True`, который смотрит в список задач.

2. **Await:** Когда корутина встречает `await`, она говорит лупу: «Я жду данных из сети, это долго. Забери у меня управление и дай его кому-то другому, а меня разбуди, когда придут данные».

3. **IO-bound:** Это идеально для задач, где процессор простаивает (сетевые запросы, чтение диска, работа с БД).

  
**Когда НЕ использовать:**  
Для **CPU-bound** задач (тяжелые вычисления, обработка видео, обучение ML-моделей). Если ты начнешь считать факториал миллиона внутри `async` функции, ты заблокируешь единственного шахматиста (Event Loop), и все остальные задачи встанут.

---

#### Вопрос: 2. GIL (Global Interpreter Lock): главный тормоз потоков
**Ответ:**
**Что это:**  
GIL — это мьютекс (глобальный замок), который гарантирует, что в любой момент времени только **один** поток может исполнять байт-код Python. Даже если у тебя процессор с 32 ядрами, стандартный Python (CPython) будет использовать только одно ядро для выполнения Python-кода.

**Зачем он нужен?**  
Из-за управления памятью в Python. Сборщик мусора использует подсчет ссылок (`reference counting`). Если два потока одновременно попытаются изменить счетчик ссылок одного объекта, произойдет утечка памяти или краш. GIL защищает от этого.

**Как обходить:**
  
1. **Multiprocessing:** Запуск отдельных процессов. У каждого процесса свой Python-интерпретатор и свой GIL.

2. **C-extensions:** Библиотеки вроде `numpy` или `pandas` написаны на C. Во время тяжелых вычислений они умеют «отпускать» GIL, позволяя другим потокам работать.

3. **Asyncio:** GIL здесь не мешает, так как поток всего один.

---

#### Вопрос: 3. Threading vs Multiprocessing vs Asyncio
**Ответ:**
Вот подробное сравнение архитектур:

|Инструмент|Тип многозадачности|GIL|Память|Для чего идеально|
|---|---|---|---|---|
|**Threading**|Вытесняющая (OS решает, когда переключить)|Мешает|Общая (потоки видят переменные друг друга)|Блокирующий I/O (старые библиотеки без async поддержки), GUI приложений.|
|**Multiprocessing**|Параллельная (разные ядра CPU)|Не мешает|Изолированная (нужна сериализация данных для обмена)|Тяжелые вычисления (CPU-bound), обработка данных, ML (препроцессинг).|
|**Asyncio**|Кооперативная (код сам отдает управление)|Не актуален|Общая (один процесс)|Высоконагруженный I/O (тысячи соединений), веб-серверы, чат-боты.|
  
---

#### Вопрос: 4. Корутина vs Функция
**Ответ:**
- **Обычная функция (`def`):** Работает линейно. Зашла -> выполнила код -> вернула результат (`return`) -> забыла всё свое состояние (локальные переменные уничтожены). Она удерживает поток всё время выполнения.

- **Корутина (`async def`):** Это функция, которую можно поставить на паузу.
  
    1. При вызове она не исполняется сразу, а возвращает объект корутины.

    2. Когда доходит до `await`, она «замораживает» свое состояние (локальные переменные) и отдает управление.

    3. Позже она продолжает работу ровно с того места, где остановилась.

  
---

#### Вопрос: 5. Event Loop (Под капотом)
**Ответ:**
Event Loop — это менеджер задач. Грубо говоря, его работа выглядит так:

1. Есть список задач `ready` (готовы к работе) и `waiting` (ждут I/O).

2. Loop берет задачу из `ready` и выполняет её до ближайшего `await`.

3. Если встретился `await future`, Loop перекладывает задачу в `waiting` и подписывается на событие (например, "сокет стал доступен для чтения").

4. Как только событие произошло, задача возвращается в `ready`.
  
5. **Важно:** Если какая-то задача зависнет без `await` (бесконечный цикл `while True`), Event Loop остановится, и программа "умрет".

---

#### Вопрос: 6. Обработка ошибок в Asyncio
**Ответ:**
Особенность в том, что исключения в фоновых задачах (Task) могут быть "проглочены", если вы явно не ожидаете их завершения.

**Нюансы `gather`:**  
Если вы запускаете пачку задач через `asyncio.gather(task1, task2)`:

- По умолчанию: если одна задача упадет с ошибкой, `gather` сразу выбросит исключение, а остальные задачи будут отменены.

- `return_exceptions=True`: `gather` вернет список, где успешные задачи будут результатами, а упавшие — объектами исключений. Это позволяет не ломать весь процесс из-за одной ошибки.

---

### Языковые конструкции для прод-кода: декораторы, контекст, генераторы

#### Вопрос: 7. Декораторы: "Матрешка" из функций
**Ответ:**
Декоратор — это просто функция, которая принимает другую функцию и возвращает новую (обертку). Это паттерн проектирования, позволяющий добавить поведение (логирование, кэширование, проверку прав) без изменения кода самой функции.

**Разбор примера:**

```python
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)  # Вызов оригинала
        print(f"Time: {time.time() - start:.2f} seconds")  # Добавочное поведение ПОСЛЕ
        return result
    return wrapper
````

**`@wraps`:** Всегда используй `functools.wraps`. Без него декорированная функция потеряет своё имя (`__name__`) и документацию (`__doc__`), превратившись просто в `wrapper`, что усложнит отладку.

---

#### Вопрос: 8. Контекстные менеджеры (`with`)

**Ответ:**
Суть не просто в "красоте кода", а в **гарантии**.
Конструкция `try...finally` громоздкая. Блок `with` гарантирует выполнение очистки ресурсов, даже если внутри блока произошла ошибка (`ZeroDivisionError`, `MemoryError` и т.д.).

**Жизненный цикл:**

1. `__enter__`: Выполняется при входе. То, что он вернет, запишется в переменную после `as`. (Например, открывает файл).

2. Тело блока `with`: Ваш код.

3. `__exit__`: Выполняется всегда при выходе. Здесь закрываются файлы, коммитятся транзакции БД или освобождаются локи. Если было исключение, оно передается в `__exit__`, где его можно подавить (вернув `True`) или пробросить дальше.

---

#### Вопрос: 9. Генераторы vs Списки

**Ответ:**
Разница в **выделении памяти**.

* **Список (`[...]`):** Ты приходишь в магазин и покупаешь **сразу 1000 коробок**. Тебе нужно место в багажнике (RAM), чтобы их увезти, и время, чтобы кассир пробил их все сразу.

* **Генератор (`yield`):** Ты заключаешь договор, что будешь забирать **по одной коробке**, когда она тебе понадобится. Тебе не нужен грузовик, ты берешь одну, обрабатываешь, выбрасываешь, идешь за следующей.

**Пример:** Чтение файла на 10 ГБ.

* Список: `readlines()` попытается загрузить 10 ГБ в память -> `MemoryError`.

* Генератор: Будет читать по одной строке, занимая пару килобайт памяти.

---

### Алгоритмы и производительность

#### Вопрос: 10. Сложность алгоритмов (Big O)

**Ответ:**
Это оценка того, как сильно замедлится программа, если данных станет **очень много**.

* **O(1) — Константная:** Время выполнения не зависит от данных. Взять элемент словаря по ключу (`dict[key]`). Хоть в словаре 5 записей, хоть 5 миллионов — скорость одинаковая (почти).

* **O(log n) — Логарифмическая:** Данные удваиваются, а время растет лишь на 1 шаг. Это **бинарный поиск**. Представь телефонную книгу: каждый раз ты делишь книгу пополам.

* **O(n) — Линейная:** Проход по списку циклом `for`. В 10 раз больше данных — в 10 раз дольше ждать.

* **O(n²) — Квадратичная:** Вложенные циклы (пузырьковая сортировка). Данных стало больше в 10 раз, а время выросло в 100 раз. Это «плохая» сложность для больших данных.

---

#### Вопрос: 11. Оптимизация памяти: что реально работает

**Ответ:**

* **`__slots__`**: По умолчанию каждый объект класса хранит атрибуты в словаре `__dict__`. Словарь — структура прожорливая (хеш-таблица с запасом памяти). Если у тебя миллионы объектов (например, точки графика или строки из БД), `__slots__` говорит интерпретатору: «Не создавай словарь, выдели память жестко под эти 3 переменных». Экономия памяти в 40-50%.

  * *Минус:* Нельзя динамически добавить новый атрибут объекту.

* **Генераторы**: Не хранят данные, а вычисляют их на лету. Это база для ETL-процессов.

* **`gc.collect()`**: В Python GC работает автоматически. Ручной вызов нужен крайне редко (например, после освобождения огромного куска памяти в долгоживущем процессе, чтобы вернуть память ОС, или если отключен автоматический GC для оптимизации, как делали в Instagram).

---

#### Вопрос: 12. List Comprehension: скорость vs читаемость

**Ответ:**
Почему это быстрее обычного цикла `for`?
Когда ты пишешь `[x**2 for x in range(10)]`, инструкция создания списка выполняется на уровне C (байт-код `LIST_APPEND`), внутри оптимизированного цикла интерпретатора.
В обычном `for` с `append()` интерпретатор на каждой итерации ищет метод `append` у объекта списка, вызывает его как Python-функцию — это накладные расходы.

* *Совет:* Не используй вложенные comprehension (больше 2 уровней) — это невозможно читать и отлаживать.

---

#### Вопрос: 13. *args и **kwargs: Распаковка и запаковка

**Ответ:**
Это не просто «аргументы». Это операторы управления коллекциями.

* **В определении функции:** `*` собирает остаток позиционных аргументов в кортеж, `**` собирает именованные в словарь.

* **В вызове функции:** Они делают обратное — распаковывают.

  ```python
    params = {'a': 1, 'b': 2}
    func(**params)  # Эквивалентно func(a=1, b=2)
  ```

Это критически важно при написании оберток (декораторов) или при наследовании, когда ты прокидываешь аргументы в `super().__init__(*args, **kwargs)`, не зная заранее, что там.

---

### Память, GC и модель объектов

#### Вопрос: 14. Garbage Collection (GC): Двухуровневая система

**Ответ:**

1. **Reference Counting (Подсчет ссылок):** Это главная линия обороны. Как только на объект никто не ссылается (`ref_count == 0`), память освобождается **моментально**. Это детерминированное поведение.

2. **Generational GC (Сборщик мусора для циклов):**

   * *Проблема:* Объект А ссылается на Б, а Б на А. Ссылки есть (count=1), но из программы к ним доступа нет. RefCount их не удалит.

   * *Решение:* Периодически просыпается GC, останавливает программу (на микросекунды) и сканирует объекты на наличие таких изолированных островков.

   * *Поколения (Generations):* Новые объекты попадают в поколение 0. Если они выжили после проверки GC — переходят в 1, потом в 2. Чем старше поколение, тем реже его проверяют (гипотеза: если объект долго живет, он, вероятно, нужен надолго).

---

#### Вопрос: 15. Monkey Patching: Сила и опасность

**Ответ:**
Это изменение поведения кода в рантайме.

* **Где нужно:** В тестах (`unittest.mock`), чтобы база данных не дергалась реально, а возвращала фейковый ответ. Или для "горячего" фикса бага в сторонней библиотеке без пересборки.

* **Где опасно:** В продакшн-коде для бизнес-логики. Это создает "неявное поведение" (Action at a distance). Читаешь код — функция делает одно, а по факту — другое, потому что в другом файле её подменили.

---

#### Вопрос: 16. Скорость структур данных (Детали)

**Ответ:**

* **List (Динамический массив):** Это блок памяти в C.

  * `insert(0, x)` — это **O(n)**, потому что все элементы справа нужно физически сдвинуть в памяти на одну ячейку. Это убийство производительности.

* **Deque (Двусвязный список блоков):**

  * Вставка в начало и конец — **O(1)**. Идеально для очередей. Но доступ по индексу `d[500]` — **O(n)**, так как нужно пройти по цепочке ссылок до нужного блока.

* **Dict/Set (Хеш-таблица):**

  * Поиск элемента — **O(1)**. На собеседованиях часто ловят на вопросе: "Как быстро найти элемент в списке?". Ответ: "Медленно, O(n). Преобразуйте в set, будет O(1)".

---

#### Вопрос: 17. Mutable vs Immutable: Ловушка дефолтных аргументов

**Ответ:**
Почему `def f(l=[]):` — это зло?
Значения дефолтных аргументов создаются **один раз** при загрузке модуля (когда Python читает определение функции `def`), а не при каждом вызове функции.
Поэтому список `l` становится общим для всех вызовов функции. Изменяя его внутри, ты меняешь тот самый единственный объект, созданный при старте.
`None` — неизменяемый синглтон, поэтому идиома `if x is None: x = []` работает корректно (создает новый список каждый раз).

---

#### Вопрос: 18. Магические методы: `__new__` vs `__init__`

**Ответ:**

* **`__init__`**: Инициализатор. Объект уже создан и лежит в памяти, мы просто заполняем его поля (`self.x = 1`). Ничего не возвращает.

* **`__new__`**: Конструктор. Реально создает объект. Это статический метод, который должен вернуть экземпляр класса.

  * *Зачем нужен?*

    1. Для создания **Singleton** (проверить, есть ли инстанс, и вернуть старый, если есть).

    2. Для наследования от неизменяемых типов (`int`, `str`, `tuple`). Ты не можешь изменить `int` в `__init__`, он уже создан. Его нужно модифицировать на этапе создания в `__new__`.

---

#### Вопрос: 19. `@staticmethod` vs `@classmethod`

**Ответ:**

* **`@staticmethod`**: Просто функция, которая "живет" внутри класса для порядка. Она ничего не знает о классе.

* **`@classmethod`**: Получает `cls` (сам класс) первым аргументом.

  * *Главный кейс:* Альтернативные конструкторы.

```python
class Date:     
    def __init__(self, d, m, y):
        self.d = d
        self.m = m
        self.y = y
    
    @classmethod    
    def from_string(cls, str_date):
        # парсим строку "2024-01-01"
        d, m, y = map(int, str_date.split('-'))
        return cls(d, m, y)  # cls гарантирует, что при наследовании вернется нужный класс
```

---

### ML-специфика и детали интерпретатора

#### Вопрос: 20. `model(x)` vs `model.forward(x)` (PyTorch)

**Ответ:**
Это классика ML.

* **`forward(x)`**: Это просто твой метод с математикой нейросети.

* **`model(x)` (вызов `__call__`)**: Это обертка PyTorch. Перед вызовом твоего `forward` она запускает **Pre-hooks**, а после — **Post-hooks**.

  * Без этого не будут работать: подсчет градиентов (autograd может сбиться), хуки для дебага слоев, JIT-компиляция и переключение режимов `train/eval`. Никогда не вызывай `forward` напрямую.

---

#### Вопрос: 21. Сортировка Timsort

**Ответ:**
Python использует Timsort (разработан Тимом Питерсом). Это комбинация **Merge Sort** и **Insertion Sort**.

* **Идея:** Реальные данные редко бывают полностью хаотичны. Часто там есть уже отсортированные куски ("runs"). Timsort находит их и сливает.

* **Стабильность (Stable):** Если у двух объектов одинаковый ключ сортировки, их порядок относительно друг друга не изменится. Это важно при сортировке по нескольким критериям (сначала по имени, потом по возрасту).

---

#### Вопрос: 22. Коллизии в dict: Открытая адресация

**Ответ:**
Как Python решает, куда положить пару, если `hash(key1) % size` совпадает с `hash(key2) % size`?
Он не создает список (связный список) в этой ячейке (как делали раньше в Java). Он использует **Open Addressing**.
Если ячейка занята, Python вычисляет новый индекс по хитрой формуле (псевдорандомное пробирование) и смотрит туда. И так пока не найдет пустое место.
Именно поэтому удаление из словаря — сложная операция (нужно ставить метку "dummy", чтобы не разорвать цепочку поиска для других ключей).

---

#### Вопрос: 23. Вещественные числа (IEEE 754)

**Ответ:**
Проблема не в Python, а в аппаратной реализации `float`.
Компьютеры работают в двоичной системе.
Число `0.1` (одна десятая) в десятичной системе конечное. А в двоичной — это **бесконечная периодическая дробь**(0.0001100110011...).
Память ограничена (64 бита), поэтому хвост обрезается. Возникает ошибка округления.

* *Решение для денег/финансов:* Использовать `Decimal` (хранит числа как строки/целые с экспонентой) или хранить деньги в копейках (`int`).

---

#### Вопрос: 24. Ссылочная модель данных

**Ответ:**
В С++ переменная — это "ящик", в котором лежит значение.
В Python переменная — это "стикер" (имя), который приклеен к объекту в куче (heap).

```python
a = [1, 2]
b = a  # Мы просто наклеили второй стикер на ТОТ ЖЕ объект
b.append(3)
print(a)  # [1, 2, 3] — потому что объект один
```

Оператор `=` в Python никогда не копирует данные. Он всегда копирует ссылку. Чтобы скопировать данные, нужно делать явный `copy()` или `deepcopy()`.

```